## P6 课下感想☹️

### 思考题

1. 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。

> 提前分支判断虽然能够减少控制冒险带来的开销，但其效率依赖于预测的准确性和流水线结构的设计。如果分支预测错误，仍然需要清空流水线，从而造成性能损失。同时，提前计算可能会导致额外的数据冒险问题，例如与尚未写回的结果相关的依赖关系。
>
> **示例指令序列**
> 以下是一个可能导致问题的指令序列：
>
> ```assembly
> 1. BEQ R1, R2, Label  ; 分支条件判断
> 2. ADD R3, R4, R5     ; 分支未确认前的后续指令
> 3. Label: SUB R6, R7, R8 ; 分支跳转目标指令
> ```
>
> 在上述序列中，如果分支预测错误，指令 2 的执行结果会被废弃，浪费了计算资源。此外，如果指令 3 的输入依赖指令 2 的结果，还可能导致数据冒险问题。

2. 因为延迟槽的存在，对于 `jal` 等需要将指令地址写入寄存器的指令，要写回 `PC + 8`，请思考为什么这样设计？

> jal 指令需要保存返回地址以支持子程序调用和返回。在流水线架构中，由于延迟槽的存在，jal 的后续一条指令会在跳转前执行，因此保存的返回地址必须是跳转指令后两条指令的地址（即 PC + 8），以确保程序可以正确返回到调用点后的下一条指令。

3. 我们要求所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？

> 转发数据直接来自流水寄存器而非功能部件，主要是为了减少数据传输的复杂性和延迟
> 1. 功能部件的计算结果可能需要额外的处理时间（如内存读取延迟），增加了数据转发的延迟。
> 2. 流水寄存器内的数据已经在上一阶段计算完成且稳定，可以保证及时性和一致性，减少冒险发生的概率。


4. 我们为什么要使用 GPR 内部转发？该如何实现？

>  GPR（通用寄存器）内部转发的目的是减少数据冒险延迟，提升指令执行效率。在指令依赖尚未写回的情况下，通过转发机制直接提供数据，而不是等待寄存器文件更新。

5. 我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？

> **数据来源**
> 供给者可以来源于以下位置：
>
> 1. EX/MEM 阶段寄存器（ALU 结果）。
> 2. MEM/WB 阶段寄存器（内存读取或 ALU 写回结果）。
>
> **数据需求者**
> 需求者主要来自以下位置：
>
> 1. ID 阶段的操作数获取。
> 2. EX 阶段的指令操作数。
>
> **数据通路**
> 典型的转发通路包括：
>
> 1. EX/MEM 到 EX 转发。
> 2. MEM/WB 到 EX 转发。
> 3. MEM/WB 到 ID 转发。

6. 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。

> **分类与修改分析**
>
> 1. 算术逻辑类指令
>    - 扩展 ALU 的功能模块，以支持新的运算类型。
>    - 修改译码器，增加对新操作码的识别和处理。
> 2. 访存类指令
>    - 扩展 MEM 阶段以支持新的内存访问方式（如块加载或按位操作）。
>    - 修改地址生成逻辑，支持更复杂的偏移计算。
> 3. 分支类指令
>    - 修改分支预测单元以适配新指令的跳转模式。
>    - 扩展分支判断逻辑，确保准确处理条件跳转。

7. 简要描述你的译码器架构，并思考该架构的优势以及不足。

>    详细请看设计图

## P6 课上测试感想😇