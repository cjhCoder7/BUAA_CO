## P6X 课下感想☹️

详细请看设计图 [CPU流水线](CPU流水线.pdf)

### 思考题

1. 我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。

> 提前分支判断虽然能够减少控制冒险带来的开销，但其效率依赖于预测的准确性和流水线结构的设计。如果分支预测错误，仍然需要清空流水线，从而造成性能损失。同时，提前计算可能会导致额外的数据冒险问题，例如与尚未写回的结果相关的依赖关系。
>
> **示例指令序列**
> 以下是一个可能导致问题的指令序列：
>
> ```assembly
> 1. BEQ R1, R2, Label  ; 分支条件判断
> 2. ADD R3, R4, R5     ; 分支未确认前的后续指令
> 3. Label: SUB R6, R7, R8 ; 分支跳转目标指令
> ```
>
> 在上述序列中，如果分支预测错误，指令 2 的执行结果会被废弃，浪费了计算资源。此外，如果指令 3 的输入依赖指令 2 的结果，还可能导致数据冒险问题。

2. 因为延迟槽的存在，对于 `jal` 等需要将指令地址写入寄存器的指令，要写回 `PC + 8`，请思考为什么这样设计？

> jal 指令需要保存返回地址以支持子程序调用和返回。在流水线架构中，由于延迟槽的存在，jal 的后续一条指令会在跳转前执行，因此保存的返回地址必须是跳转指令后两条指令的地址（即 PC + 8），以确保程序可以正确返回到调用点后的下一条指令。

3. 我们要求所有转发数据都来源于流水寄存器而不能是功能部件（如 DM、ALU），请思考为什么？

> 转发数据直接来自流水寄存器而非功能部件，主要是为了减少数据传输的复杂性和延迟
> 1. 功能部件的计算结果可能需要额外的处理时间（如内存读取延迟），增加了数据转发的延迟。
> 2. 流水寄存器内的数据已经在上一阶段计算完成且稳定，可以保证及时性和一致性，减少冒险发生的概率。


4. 我们为什么要使用 GPR 内部转发？该如何实现？

>  GPR（通用寄存器）内部转发的目的是减少数据冒险延迟，提升指令执行效率。在指令依赖尚未写回的情况下，通过转发机制直接提供数据，而不是等待寄存器文件更新。

5. 我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？

> **数据来源**
> 供给者可以来源于以下位置：
>
> 1. EX/MEM 阶段寄存器（ALU 结果）。
> 2. MEM/WB 阶段寄存器（内存读取或 ALU 写回结果）。
>
> **数据需求者**
> 需求者主要来自以下位置：
>
> 1. ID 阶段的操作数获取。
> 2. EX 阶段的指令操作数。
>
> **数据通路**
> 典型的转发通路包括：
>
> 1. EX/MEM 到 EX 转发。
> 2. MEM/WB 到 EX 转发。
> 3. MEM/WB 到 ID 转发。

6. 在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。

> **分类与修改分析**
>
> 1. 算术逻辑类指令
>    - 扩展 ALU 的功能模块，以支持新的运算类型。
>    - 修改译码器，增加对新操作码的识别和处理。
> 2. 访存类指令
>    - 扩展 MEM 阶段以支持新的内存访问方式（如块加载或按位操作）。
>    - 修改地址生成逻辑，支持更复杂的偏移计算。
> 3. 分支类指令
>    - 修改分支预测单元以适配新指令的跳转模式。
>    - 扩展分支判断逻辑，确保准确处理条件跳转。

7. 简要描述你的译码器架构，并思考该架构的优势以及不足。

>    详细请看设计图

## P6X 课上测试感想😇

终于通过P6X了，难受~~~~

![](result.png)

如图所示，鄙人十分难受地在P6X挂了两次，总共是考了三次才通过，而且通过的那一次也没有做出全部的题出来，只做出来两道题😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭😭

**一点点小总结**

还是要多看**以前学长关于流水线课上考试的博客**，然后总结各个类型指令的添加方法，最好是在课下要自己实践一下，这样在课上考试的时候心理才有底

一般来说有以下套路：

- **计算类指令**：直接在ALU模块中更改就可以了
- **访存类指令**：一般来说，需要根据`DM`中取出的值再进行判断回写寄存器的地址，回写地址产生的时间靠后，转发不能解决冲突问题，所以需要<u>暂停处理</u>，通常情况直接在ALU的那个阶段强制暂停一次就可以了，但是*有些指令需要特殊考虑*。
- **跳转类指令**：这个直接在D级流水线进行处理，包括CMP的比较，判断是否进行写31号寄存器等等。需要注意的时，如果判断出的结果是不需要写入31号寄存器，可以直接将A3改为0（因为0号寄存器是不能进行写入的），而不是将condition流水下去（这可能会导致一些奇奇怪怪的bug😂😂😂😂）

流水线完工！脱离苦海，祝Cache实验顺利！！！